% This is part of the stat-toolkit documentation
% Copyright (C) 2012,2013 Krzysztof Stachowiak
% See the file FDL for copying conditions.

\documentclass{report}

\begin{document}

\title{The statistical toolkit documentation/manual}
\author{Krzysztof Stachowiak}
\date{\today}

\maketitle

\tableofcontents

\section*{License note}
This is part of the stat-toolkit documentation.\\
Copyright (C) 2012,2013 Krzysztof Stachowiak\\
See the file FDL for copying conditions.

\chapter{Libraries}

% Things that should be found in a library section:
% - Summary
%   - The namespaces and the classes
%   - The interface of the relevant classes

\section{Overview}
The libraries, which in this suite take a form of autonomous and atomic C++
header files are the foundation of the entire system. In many cases they are
uniquely tied to one of the command line tools, but others are shared between
the programs. Regardles of the particular use in the suite they are designed to
be as generic as possible and enable potiential use outside of the toolkit.
Therefore their interdependencies are minimized so that in many cases a
particular header file may be simply copied and pasted in another
project\footnote{Note however, that most of them still depends on some of the boost
libraries, so the point is not that they are lightweight, but that they may be
used separately.}.

\section{\texttt{aggr.h}}

	\subsection{Summary}
	The \texttt{aggr.h} library provides a set of classes for aggregating data.
	All of its contents are enclosed within the \texttt{aggr} namespace. The
	aggregation classes are derived from an abstract class \texttt{aggregator}
	which defines the concept of an aggregator. The interface is simple and
	consists of two functions: \texttt{put} and \texttt{get}.

	\begin{itemize}
		\item \texttt{put(value : double) : void}\\
			This function allows storing a value in the aggregator.
		\item \texttt{get() : double}\\
			This function returns a value that is the result of the
			underlying agregation.
	\end{itemize}

	The \texttt{get} function may be called at any time as the aggregators are
	designed to compute their results dynamically. 

	\paragraph{Note}
	A convenient typedef has been placed in the \texttt{aggr} namespace to ease
	defining types based on an abstract pointer to an aggregator:\\
	\texttt{typedef unique\_ptr<aggregator> ptr;}

	\subsubsection{Available aggregators}
	There is a set of basic classes that the library provides:

	\begin{itemize}
		\item \texttt{count} - Counts the elements that are put into the aggregator.
		\item \texttt{sum} - Sums the elements that are put into the aggregator.
		\item \texttt{mean} - Computes the mean value of the input values.
		\item \texttt{stdev} - Computes the standard deviation of the input values.
		\item \texttt{ci\_gauss} - Computes the width of the confidence
			interval defined based on the input data and a predefined
			confidence level, assuming normal distribution.
	\end{itemize}

	\subsubsection{Uniform aggregators construction}
	All the aggregators can be instantiated uniformly with use of the function:
	\texttt{create\_from\_string(str : string) : unique\_ptr<aggregator>}.
	It is used by all the command line tools that accept the aggregator definitions
	from the command line arguments. The format for the string constructing an
	aggregator is:
	\begin{center}
		\texttt{\textit{aggregator-name} [\texttt{aggregator-argument-list}]}
	\end{center}
	The function will throw a string object upon receiving an unrecognized constructor
	string.

	The aggregator names are the same as the names of the respective classes. Currently
	only one of the aggregators requires an argument, which is the \texttt{ci\_gauss}
	expecting a single argument - the confidence level.

\section{\texttt{groupby.h}}

	\subsection{Summary}
	The \texttt{groupby.h} library provides functionality silimar to the SQL
	groupping. In order to perform the aggregation of a set of data, two
	things need to be defined. The set of the group defining columns
	(the \texttt{group by} part in the SQL query), and the set of the aggregators
	(the \texttt{SUM(?)}, \texttt{MEAN(?)}, etc. SQL functions). The values from
	the input rows are groupped by the criteria given by the first set and then
	within each group the values are aggregated with te functions provided by
	the aggregators.

	All the classes are placed in the \texttt{groupby} namespace. There are three
	of them:

	\begin{itemize}
		\item \texttt{group} -- Internal representation of a data group.
			This one should not be used outside of the library.
		\item \texttt{group\_result} -- This class is meant as a mean of
			safely transporting the groupping result. Instead of
			polymorphic aggregator pointers it already stores the
			aggregated values and is therefore easily copyable and
			movable.
		\item \texttt{groupper} -- The main facility of the library. It
			is defined by the aforementioned concepts of groupping
			columns and aggregators and works by consuming plain data
			rows and exposing the groupping results upon request.
	\end{itemize}

	Two of the classes will be described here as the ones meant to be used by
	the library clients.

	\subsection{groupper}
	The main functional class being constructed with two arguments:

	\begin{itemize}
		\item \texttt{groupbys : vector<uint32\_t>} -- The list of the
			indices defining the groupping columns.
		\item \texttt{aggr\_strs : vector<string>} -- The strings for
			the construction of the aggregators. They are given by
			the pairs of the form: \textit{column-index constructor},
			where the \textit{column-index} indicates the column from
			which the values are to be aggregated and the
			\textit{constructor} is the aggregator constructor string.
			For the details on the aggregator construction from strings
			see the \texttt{aggr.h} library section of the manual.
	\end{itemize}

	The runtime interface of the \texttt{groupper} class consists the following
	functions:

	\begin{itemize}
		\item \texttt{consume\_row(row : vector<string>) : void}\\
			Accepts a row of data and asigns the according values to
			their groups.
		\item \texttt{for\_each\_group(f : function<void(group)>) : void}\\
			Visits all the groups that have been determined so far
			calling the provided function for each of them.
		\item \texttt{copy\_result() : vector<group\_result>}\\
			Performs all the aggregations of the values stored for the
			internal list of groups and returns a static copy of
			the groupping result that only contains the aggregated
			values.
	\end{itemize}

	\subsection{group\_result}
	This class serves the purpose of transporting the
	information about the groupping result in a safe, copyable and movable
	way. It consists of two lists:

	\begin{itemize}
		\item \texttt{definition : vector<pair<uint32\_t, string>>}\\
			The mapping of the column indices and the values that
			can be found in the columns for the given group.
		\item \texttt{aggregators : vector<pair<uint32\_t, double>>}\\
			The mapping of the column indices and the aggregations
			of the values coming from the columns.
	\end{itemize}

\section{\texttt{histogram.h}}

	\subsection{Summary}
	The \texttt{histogram.h} is a simple library providing a histogram
	analysis for a stream of data. It is configured with a width of the
	interval for each of the histogram bars. It exposes a simple interface
	consisting of two functions: \texttt{put} and \texttt{get\_buckets}.

	\begin{itemize}
		\item \texttt{put(value : doule) : void}\\
			This function stores a value in the histogram.
		\item \texttt{get\_buckets() : map<double, double>}\\
			This function retrieves a map defining the current state
			of the histogram. The structure maps from the intervals'
			(buckets') centers to the counts of the values that fell
			into them.
	\end{itemize}

	\paragraph{Note}
	When the values are put into the histogram object, they are assigned 
	certain buckets, which centers are computed based on the values themselves.
	However when we retrieve the final histogram, this structure may be invalid
	due to the existence of empty buckets. Such empty buckets must be generated
	which has been judged a relatively complex task and therefore such result is
	cached. Upon each call to the \texttt{put} function the cache is invalidated
	and rebuilt when the \texttt{get\_buckets} function is called subsequently.

\chapter{Command Line Interface tools}

% Things that should be found in a cli tool section:
% - List of all options with short descriptions
% - Summary
%   - The explanation of all the concepts (refer to the underlying libraries
%		where possible).
% - Examples

\section{\texttt{histogram}}

	\subsection{All options}
	\begin{itemize}
		\item \texttt{-d} \textit{delimiter} -- Allows selection of a custom
			delimiter for the output data.
		\item \texttt{-w} \textit{bucket-width} -- Determines the width of the
			histogram bucket. The default value is 1.0.
	\end{itemize}

	\subsection{Summary}
	The program takes a list of numbers, one number per line and builds
	a histogram of the provided distribution. The default bucket width is 1.0,
	but this setting may be overriden with use of the \texttt{-w \textit{width}}
	option.

	The output consists of two columns. The first column is built of the bucket
	center values, whereas in the second columnt the number of the results that
	fell into the according bucket is given. By default the columns are separated
	with the tab character, but this behavior can be altered with use of the
	\texttt{-d \textit{delimiter}} option.

	The program automatically generates empty buckets for the ranges, for which
	there were no results, therefore the data is ready for further processing.

\section{\texttt{aggr}}

	\subsection{Summary}
	This trivial tool accepts a list of numbers at its standard input and performs 
	one of the basic aggregations. The aggregator is shosen by the one and only
	command line argument, which is the aggregator construction string. For the
	details on the available aggregators and their respective construction strings
	see the manual for the \texttt{aggr.h} library.

\section{\texttt{groupby}}

	\subsection{All options}
	\begin{itemize}
		\item \texttt{-a} \textit{constr-string} -- defines an aggregator with a
			so called construction string.
		\item \texttt{-d} \textit{delim-char} -- defines a custom delimiter.
			The default value is the tab character.
		\item \texttt{-g} \textit{group-index} -- defines a groupping criterion.
	\end{itemize}

	\subsection{Summary}
	The program performs SQL-like groupping aggregation of a set of data given by a
	stream of tabuarized textual data. It is based upon the \texttt{groupby.h} library.

	A stream of data rows separated with a linebreak is expected. The default
	field separator is the tab character, but may be altered with the
	\texttt{-d \textit{delimiter}} option. The output is defined by two sets
	of the data processing elments: the groupping criteria and the aggregators.
	It is required that there is at least one groupping criterion and at least one
	aggregator defined in the command line. Note that they will appear in the output
	in the same order in which they're given in the command line.

	\subsubsection{Groupping criteria}
	The grouppers are equivalent to the SQL's ``group by'' statements.
	Assumed that we have selected a set of grouppers for fields f1, f2, etc.,
	All the input data rows that have the same values in these fields will be
	considered groupped. We will be furhter saying they belong to a single group.
	The fields are given by indices; in order to define a groupping criterion we use
	a \texttt{-g \textit{column-index}} option.

	\subsubsection{Aggregators}
	The aggregators define the way in which given values for the specific fields
	are to be put together. Defining an aggregator consists in providing a
	\texttt{-a "\textit{field-index} \textit{aggr-constr}"} option, where the
	\textit{field-index} indicates the field that is to be aggregated by the
	current aggregator and \textit{aggr-constr} means the string constructing
	a given aggregator. The field index is a non-negative, zero-based index
	of a particular column, and the constructor string is the name of the
	aggregator followed by optional, aggregator-specific arguments. For details see
	the aggregator construction in the manual for the \texttt{aggr.h} library.

	For example in order to define an aggregator for the field 3 that will compute
	the gaussion confidence interval at the confidence level of 0.95 the argument
	line should be:

	\texttt{... | ./groupby ... -a "3 ci\_gauss 0.95" ...}

	\subsubsection{Output format}
	Let's assume that fields \texttt{f1, f2, ...} have been chosen as the
	grouppers and aggregators \texttt{a1, a2, ...} have been selected.
	The results will take the following form:
	\begin{verbatim}
	f1 f2 ... a1 a2 ...
	i1 i2 ... v1 v2 ...
	i3 i4 ... v3 v4 ...
	\end{verbatim}

	... where \texttt{i1, i2, ...} -- the "indicators" -- are the labels for
	the given fields that have been captured and \texttt{v1, v2, ...} are
	the computed aggregated values.

	\subsection{Examples}
	Let's consider a simple dataset:
	\begin{verbatim}
	$cat data
	50	4	1.0	2.0
	50	4	3.0	4.0
	50	6	1.0	2.0
	50	6	3.0	4.0
	100	4	1.0	2.0
	100	4	3.0	4.0
	100	6	1.0	2.0
	100	6	3.0	4.0
	\end{verbatim}

	Let's now take a look at different results depending on the input options.

	\begin{verbatim}
	$cat data | ./groupby -g1 -a "2 sum"
	1	"2 sum"
	4	8
	6	8
	\end{verbatim}

	\begin{verbatim}
	$cat data | ./groupby -g0 -g1 -a "2 sum" -a "3 mean"
	0	1	"2 sum"	"3 mean"
	50	4	4	3
	50	6	4	3
	100	4	4	3
	100	6	4	3
	\end{verbatim}

	\begin{verbatim}
	$cat data | ./groupby -g1 -g0 -a "2 sum" -a "3 mean"
	1	0	"2 sum"	"3 mean"
	4	50	4	3
	6	50	4	3
	4	100	4	3
	6	100	4	3
	\end{verbatim}

	\begin{verbatim}
	$cat data | ./groupby -g1 -g0 -a "3 mean" -a "2 sum"
	1	0	"3 mean"	"2 sum"
	4	50	3	4
	6	50	3	4
	4	100	3	4
	6	100	3	4
	\end{verbatim}

\section{\texttt{pivot}}

	\subsection{All options}
	\begin{itemize}
		\item \texttt{-a} \textit{constr-string} -- defines an aggregator with a
			so called construction string.
		\item \texttt{-d} \textit{delim-char} -- defines a custom delimiter.
			The default value is the tab character.
		\item \texttt{-D} \textit{dimension-string} -- defines one of the pivot
			table dimensions.
		\item \texttt{-n} -- Hides the dimension domain, so that instead of printing
			"col = value" only prints a value.
		\item \texttt{-h} -- Enables printing of the page, row and column
			captions in the resulting table.
		\item \texttt{-H} -- Read the first input row as the list of the input
			columns' captions.
	\end{itemize}

	\subsection{Summary}
	This program performs a pivot table analysis of the input data. It enables
	selecting 2 or 3 dimensions for the result space, selecting a set of the
	aggregators and few additional minor settings.

	\subsubsection{Dimensions}
	2 or 3 dimensions can be defined. The respective cases these are: page, row
	and column, or just row and column. Their interpretation is that all the values
	at a given coordinate, say in the given page, come from the input rows that fultil
	the dimension definition. Since the dimension is given by a pair: input column,
	value, fulfuling dimension definition means that the given input data row has
	a particular value in the column x, another particular value in the column y, etc.
	The dimension definition is done by a \texttt{-D} option followed by a string
	consisting of a white space separated list of the indices of the columns that are
	to form the given dimension. The dimensions are interpreted in the order in which
	they appear in the command line. The order is: page, row, column or just row, column
	if only two dimensions are given.

	\subsubsection{Aggregations}
	The aggregations determine, how the values in the resulting table will be obtained.
	Usually many values from the input rows will be directed to a given cell (defined
	by a set of 2 or 3 coordinates). All the values are aggregated so the result may
	be obtained. The aggregation is defined by a source column index and the aggregator
	construction string. For the details on the aggregator construction strings see
	the manual section for the \texttt{aggr} library.

	\subsubsection{Decorating the output table}
	Demending on the purpose the output table may or may not need to be described. If
	we expect further processing in the pipeline it may be more convenient to only
	print the values, whereas if the result is to be analyzed by a human, the row and
	the column captions should be added. By default the captions(headers) are not
	printed, but the behavior may be altered by adding an option: \texttt{-h} to the
	command line.

	\subsubsection{The input data header}
	The input data set may or may not contain an additional header row providing
	labels for the columns. Even though the input options (e.g. the dimension
	definitions) is always given by the column indices, the ouptut may be more
	readable if based on the original column captions (an aggregator may tor example
	be labeled "mean(result)" instead of "mean(4)". To indicate that the first input
	row should be interpreted as the header row providing the captions an option:
	\texttt{-H} must be added to the command line.

	\subsubsection{Customizing the dimension descriptor printing}
	By default the dimension caption will be of a format "column = value" for each
	of the dimension's column. This behavior may clutter the output, and therefore
	it can be disabled. In order to hide the domain of the dimension descriptor so that
	they will only consist of a "value" string for each of the dimension's columns
	append a \texttt{-n} option.

	\paragraph{Note}
	It may happen that for some cell in the pivot table (i.e. for a given page, row
	and column) there will be no results in the given input data. In such case an
	``x'' character is put in the result table.

\end{document}
